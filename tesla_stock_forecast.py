# -*- coding: utf-8 -*-
"""Tesla Stock Forecast.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SftxIxfXUfyLaH1YBKo1DjfKMsQYSm8N
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from prophet import Prophet
from sklearn.metrics import mean_squared_error, mean_absolute_error

data = pd.read_csv('/content/TSLA.csv')
data.head(5)

# check for the null values

data.isnull().sum()

data.describe()



"""# Plot all numerical features"""

import warnings
warnings.filterwarnings("ignore", category=FutureWarning, module="seaborn")

# Ensure datetime index
data['Date'] = pd.to_datetime(data['Date'], format='%Y-%m-%d')
data = data.set_index('Date')

# Create subplots
fig, ax = plt.subplots(nrows=2, ncols=3, figsize=(15,10))

sns.lineplot(x=data.index, y=data['Open'], ax=ax[0,0])
ax[0,0].set_title('Open Price')
ax[0,0].set_ylabel('Price ($)')
ax[0,0].set_xlabel('Date')

sns.lineplot(x=data.index, y=data['High'], ax=ax[0,1])
ax[0,1].set_title('High Price')
ax[0,1].set_ylabel('Price ($)')
ax[0,1].set_xlabel('Date')

sns.lineplot(x=data.index, y=data['Low'], ax=ax[0,2])
ax[0,2].set_title('Low Price')
ax[0,2].set_ylabel('Price ($)')
ax[0,2].set_xlabel('Date')

sns.lineplot(x=data.index, y=data['Close'], ax=ax[1,0])
ax[1,0].set_title('Close Price')
ax[1,0].set_ylabel('Price ($)')
ax[1,0].set_xlabel('Date')

sns.lineplot(x=data.index, y=data['Adj Close'], ax=ax[1,1])
ax[1,1].set_title('Adjusted Close Price')
ax[1,1].set_ylabel('Price ($)')
ax[1,1].set_xlabel('Date')

sns.lineplot(x=data.index, y=data['Volume'], ax=ax[1,2])
ax[1,2].set_title('Volume')
ax[1,2].set_ylabel('Volume')
ax[1,2].set_xlabel('Date')

# Avoid overlapping labels
plt.tight_layout()
plt.show()

"""# Overall Insights:

- Tesla's stock price showed a long period of relative stability followed by an exponential rise in recent years.

- The volume spikes correlate with the price surge phases, suggesting increased trader interest and possibly volatility.

- The price and volume patterns are typical of a growth stock experiencing accelerated investor demand.
"""

data.plot(y=['Open', 'High', 'Low', 'Close', 'Adj Close'], figsize=(15,6))
plt.title("Tesla Stock Prices Over Time")
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.show()

"""The close alignment of price metrics underlines typical daily trading ranges.

The plot provides the overall price movement context for deeper analysis like forecasting, volatility, or volume studies.

# Daily Returns & Log Returns
**- Understand volatility and distribution of returns:**
"""

# Simple return
data['simple_returns'] = data['Adj Close'].pct_change()

# Log return
data['log_returns'] = np.log(data['Adj Close']).diff()

fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(15,5))
data['simple_returns'].hist(bins=100, ax=ax[0])
data['log_returns'].hist(bins=100, ax=ax[1])
plt.show()

"""# Volatility Analysis¶
**- Rolling statistics to see changing trends & risk:**
"""

data['rolling_mean_30'] = data['Adj Close'].shift(1).rolling(30).mean()
data['rolling_std_30'] = data['Adj Close'].shift(1).rolling(30).std()

data[['Adj Close', 'rolling_mean_30', 'rolling_std_30']].plot(figsize=(15,6))
plt.title("30-day Rolling Mean of Tesla")
plt.show()

"""# Insights:

- The rolling mean closely follows the adjusted close price, smoothing abrupt fluctuations and revealing longer-term trends.

- During the initial phase, the stock price was relatively stable, and rolling STD was low, indicating little price volatility.

- As the stock price surged starting about 2019-2020, volatility (rolling STD) also increased significantly, reflecting more unstable and rapid price changes.

- The rising rolling STD indicates more uncertainty or risk in the stock price during that period.

- The rolling mean helps identify the underlying trend amidst such volatility.

# Correlation Analysis
**- Between OHLC and Volume**:
"""

col = data[['Open','High','Low','Close','Adj Close','Volume']].corr()
sns.heatmap(col, annot=True, cmap='coolwarm')
plt.show()

"""# Insights

Perfect Correlation Among Price Metrics: The most prominent feature is the deep red block with values of 1. This indicates that the Open, High, Low, Close, and Adjusted Close prices are almost perfectly correlated with each other. This is expected, as these values all represent the price of a stock on a single day, so they move together in lockstep.

Weak Correlation with Volume: The bottom row and rightmost column show a very different story. The correlation values between Volume and all the other price metrics are very low (ranging from 0.086 to 0.094). This means that there is no linear relationship between a stock's price and its trading volume. High prices don't necessarily mean high volume, and low prices don't mean low volume.

# Candlestick Chart
**- Shows Open, High, Low, Close patterns:**
"""

pip install mplfinance

import mplfinance as mpf
mpf.plot(data[-100:], type='candle', volume=True, style='yahoo')

"""# Insights

1. The Price Trend

- Downtrend: From early November 2021 to late February 2022, the stock was in a clear downtrend. The price consistently fell from over 1200 to below 700. This period is dominated by red candlesticks, which means the price closed lower than it opened on most days.

- Reversal: Around late February 2022, the trend sharply reversed. The price started a strong uptrend, characterized by a series of tall green candlesticks. This shows a significant shift in market sentiment from selling to buying.

2. The Trading Volume

- Selling Pressure: The initial price decline from November to December was accompanied by high trading volume (tall red bars). This suggests that the downtrend was driven by strong selling pressure.

- Buying Interest: The more recent price increase (late February to March) is also happening on high volume (tall green bars). This is a bullish sign, as it indicates that the upward movement is supported by strong buying interest and is more likely to be sustained.

# Seasonality & Trend
**- Resample weekly/monthly to observe trend:**
"""

from statsmodels.tsa.seasonal import seasonal_decompose

result = seasonal_decompose(data['Adj Close'], model = 'Additive', period = 252)

result.plot()
plt.tight_layout()
plt.show()

"""# Insights:

- **Observed (Adj Close):** The top plot shows the raw data. It reveals that the stock price was relatively stable and low from 2011 to late 2019. After that, it experienced a dramatic and rapid increase, reaching a peak around 2021 before becoming highly volatile.

- **Trend:** This component captures the long-term direction of the price. It mirrors the observed data, showing a flat trend for many years followed by an extremely steep upward trend starting in late 2019. This indicates a period of explosive and sustained growth.

- **Seasonal:** This plot shows a clear and consistent annual pattern of price fluctuations. The repeating waves demonstrate a strong, predictable seasonality. This pattern likely corresponds to recurring yearly events that affect the stock, such as holiday spending cycles or annual corporate announcements.

- **Residuals (Resid):** This is the remaining noise after the trend and seasonal patterns have been removed. For most of the period (2011-2019), the residuals are small and random, which means the trend and seasonality largely explain the data. However, starting in late 2020, the residuals become much larger and more volatile, suggesting that a significant amount of the price fluctuation during this period was due to unpredictable, one-off events that the trend and seasonality cannot explain.

# Volume vs Price Relationship
**- Scatter plot to see if high volume affects price:**
"""

sns.scatterplot(x='Volume', y='Adj Close', data=data)

"""# Insights:

- No Linear Correlation: There is no clear linear relationship between price and volume. The data points are scattered widely, meaning high volume doesn't reliably correspond to high prices, and vice versa. This reinforces the finding from the correlation heatmap.

- Low Volume, High Volatility: On days with low trading volume (the dense cluster of points on the far left), the price is extremely volatile. The price can be found at any level, from near zero to over 1200. This suggests that on typical, quiet trading days, the stock's price is highly unpredictable.

- High Volume, Lower Prices: The plot also reveals an interesting pattern: there are several data points with very high volume, but they tend to correspond to lower prices. There are no data points with both extremely high volume and extremely high prices (the top-right quadrant is empty). This could indicate that significant events that cause large sell-offs are also what drive trading volume to its highest levels.

# Autocorrelation
**- See if past values predict future:**
"""

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

plot_acf(data['Adj Close'].dropna(), lags=50)
plot_pacf(data['Adj Close'].dropna(), lags=50)
plt.show()

"""# Insights:

1. Autocorrelation Plot (ACF)
The top plot shows the correlation of the time series with itself at different lags (past time steps).

- Interpretation: The correlation is very high at lag 1 and decays very slowly over time. The correlation bars stay well above the blue confidence interval for many lags. This is the classic signature of a non-stationary time series. It indicates a very strong trend in the data, where each value is highly dependent on the previous one. This confirms that the data has a clear, long-term direction.

2. Partial Autocorrelation Plot (PACF)
The bottom plot shows the correlation of the time series with its lagged values, but with the effects of all the intermediate lags removed.

- Interpretation: The partial autocorrelation is very high at lag 1 but drops off sharply at all subsequent lags. This indicates that the correlation at lags 2, 3, and so on is simply a result of the strong correlation at lag 1. This is the classic signature of a series that requires first-order differencing to remove the trend.
"""

data.columns

"""# **USING FACEBOOK PROPHET MODEL**

# Let's do some feature engineering
"""

# --- 1. Data Preparation and Feature Engineering ---

prophet_df = data.reset_index()[['Date', 'Adj Close', 'Volume', 'simple_returns', 'log_returns']].rename(
    columns={'Date': 'ds', 'Adj Close': 'y'}
)

# Engineer time-based features and lag features

prophet_df['y_orig'] = prophet_df['y']
prophet_df['y'] = np.log(prophet_df['y'])
prophet_df['y_lag1'] = prophet_df['y'].shift(1)
prophet_df['y_lag2'] = prophet_df['y'].shift(2)
prophet_df['rolling_mean_4d'] = prophet_df['y'].rolling(window=4).mean().shift(1)
prophet_df['rolling_mean_14'] = prophet_df['y'].shift(1).rolling(14).mean()
prophet_df['rolling_std_14'] = prophet_df['y'].shift(1).rolling(14).std()
prophet_df['volatility_30'] = prophet_df['y'].shift(1).rolling(30).std()



# Drop rows with NaN values created by lag and rolling operations

prophet_df = prophet_df.dropna().copy()

"""# Train test split¶
- testing on last one year data
"""

train_df = prophet_df[:-365].copy()
test_df = prophet_df[-365:].copy()

# Define regressors that are NOT future dependent

REGRESSORS = ['y_lag1', 'y_lag2', 'rolling_mean_4d','rolling_mean_14', 'rolling_std_14','volatility_30' ]

"""# Fit Prophet with regressors"""

model = Prophet(daily_seasonality=True, yearly_seasonality=True)
for r in REGRESSORS:
    model.add_regressor(r)
model.fit(train_df)

# Forecasting on the Test Set
# Create a future dataframe for the test set

future = test_df[['ds'] + REGRESSORS].copy()

# Forecast
forecast = model.predict(future)

# Ensure both test_df and forecast have the same index for alignment
test_df = test_df.reset_index(drop=True)
forecast = forecast.reset_index(drop=True)

# Reverse log transform for both actual and forecast
test_df['y_pred'] = np.exp(forecast['yhat'])
test_df['y_actual'] = np.exp(test_df['y'])

# Evaluate on the original scale
rmse = np.sqrt(mean_squared_error(test_df['y_actual'], test_df['y_pred']))
mae = mean_absolute_error(test_df['y_actual'], test_df['y_pred'])
print("\n Model Evaluation")
print("RMSE:", rmse)
print("MAE:", mae)

"""# Model Evaluation & Insights

RMSE = 30.20 → On average, predictions deviate by about $30 from actual closing prices.

MAE = 21.25 → The average absolute daily error is about $21.

Given Tesla’s trading range (~$200–$400), this corresponds to an error of roughly 7–12%, which is competitive for financial time series modeling.

# Graph Plot
"""

# Plot
plt.figure(figsize=(14,6))
plt.plot(test_df['ds'], test_df['y_actual'], label='Actual', color='blue')
plt.plot(test_df['ds'], test_df['y_pred'], label='Forecasted', color='red')
plt.legend()
plt.xlabel("Date")
plt.ylabel("Adj Close Price")
plt.title("Prophet Forecast vs Actual (Test Set) - Correct Methodology")
plt.show()

"""# Insights


**Trend Capture:**

The model (red line) closely follows the actual Tesla stock prices (blue line) over the one-year test period. This demonstrates that Prophet, when enhanced with lag-based regressors, can effectively model overall price trends and medium-term dynamics.

**Accuracy:**

With an RMSE of ~$30 and MAE of ~$21, the model maintains predictions within ~7–12% of the actual stock price range. This indicates good performance for such a volatile asset.

**Volatility Handling:**

The forecast replicates general upward and downward swings, but it smooths out sharp price spikes (e.g., around late 2021 peaks). This highlights Prophet’s strength in capturing trends but also its limitation in highly stochastic, short-term market fluctuations.

**Methodological Soundness:**

Unlike naive forecasting attempts, this model avoids data leakage by using only lagged features (y_lag1, y_lag2, rolling means). This ensures predictions rely solely on information available at the time of forecasting.

**Practical Value:**

The results show that while exact daily prices are difficult to forecast, the model is effective for directional insight, trend following, and risk-awareness applications, rather than precise intraday trading.
"""

forecast

final_df = pd.DataFrame(forecast)
import plotly.graph_objs as go
import plotly.offline as py
#Plot predicted and actual line graph with X=dates, Y=Outbound
actual_chart = go.Scatter(y=test_df['y_actual'], name= 'Actual')
predict_chart = go.Scatter(y=test_df['y_pred'], name= 'Predicted')
predict_chart_upper = go.Scatter(y=np.exp(final_df["yhat_upper"]), name= 'Predicted Upper')
predict_chart_lower = go.Scatter(y=np.exp(final_df["yhat_lower"]), name= 'Predicted Lower')
py.plot([actual_chart, predict_chart, predict_chart_upper, predict_chart_lower])